{
	"io":{
		"title": "Inżynieria Oprogramowania wszystkie pytania",
"questions":[
  {
    "id": 1,
    "question": "Oprogramowanie jest produktem materialnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 2,
    "question": "Wymagania wobec oprogramowania rzadko ulegają zmianom.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 3,
    "question": "Złe zarządzanie projektami jest jedną z przyczyn problemów z oprogramowaniem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 4,
    "question": "Częste zmiany wymagań zwiększają ryzyko niepowodzenia projektu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 5,
    "question": "Informatyka odpowiada na pytanie „jak tworzyć efektywne oprogramowanie”.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 6,
    "question": "Inżynieria oprogramowania odpowiada na pytanie „jak efektywnie tworzyć oprogramowanie”.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 7,
    "question": "Utrzymanie systemu jest elementem inżynierii oprogramowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 8,
    "question": "Programowanie proceduralne jest przykładem paradygmatu imperatywnego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 9,
    "question": "Programowanie imperatywne polega na sekwencyjnym wydawaniu poleceń.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 10,
    "question": "Model procesu przedstawia uproszczony obraz rzeczywistości.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 11,
    "question": "Model procesu zawsze opisuje wszystkie szczegóły projektu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 12,
    "question": "Model przepływu danych skupia się na danych wejściowych i wyjściowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 13,
    "question": "Model kaskadowy zakłada jednorazowe przejście przez każdą fazę.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 14,
    "question": "Zmiana wymagań w modelu kaskadowym jest w nim tania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 15,
    "question": "Model kaskadowy jest odpowiedni dla projektów z dobrze znanymi wymaganiami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 16,
    "question": "Model kaskadowy dobrze sprawdza się w dużych projektach inżynierskich.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 17,
    "question": "Tworzenie iteracyjne nie pozwala na prototypowanie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 18,
    "question": "Końcowy produkt w tworzeniu iteracyjnym często lepiej odpowiada potrzebom użytkowników.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 19,
    "question": "W tworzeniu iteracyjnym produkt powstaje stopniowo.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 20,
    "question": "W tworzeniu iteracyjnym informacja zwrotna wpływa na kolejne wersje.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 21,
    "question": "Tworzenie iteracyjne dobrze radzi sobie ze zmiennymi wymaganiami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 22,
    "question": "Metody formalne wykorzystują formalne języki specyfikacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 23,
    "question": "Metody formalne opierają się na dowodach matematycznych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 24,
    "question": "Metody formalne są często stosowane w systemach safety-critical.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 25,
    "question": "Metody formalne eliminują potrzebę testowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 26,
    "question": "Metody formalne gwarantują wysoką jakość i niezawodne oprogramowanie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 27,
    "question": "Metody formalne generują dodatkowe koszty.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 28,
    "question": "Integracja i konfiguracja opiera się na ponownym użyciu komponentów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 29,
    "question": "W integracji i konfiguracji komponenty mogą pochodzić z poprzednich projektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 30,
    "question": "W integracji i konfiguracji proces ten jest zawsze drogi i wolny.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 31,
    "question": "W integracji i konfiguracji produkt zawsze w pełni spełnia wymagania klienta.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 32,
    "question": "Metody zwinne najlepiej skalują się na duże projekty.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 33,
    "question": "W metodach zwinnych wymagania muszą być dokładnie określone na początku.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 34,
    "question": "Metody zwinne można łączyć z innymi podejściami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 35,
    "question": "CI/CD zakłada automatyczne testowanie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 36,
    "question": "DevOps integruje rozwój i wdrażanie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 37,
    "question": "DevOps jest szczególnie przydatny w chmurze.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 38,
    "question": "DevSecOps rozszerza DevOps o bezpieczeństwo.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 39,
    "question": "Czy testy mają niski koszt?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 40,
    "question": "Koszt tworzenia oprogramowania zależy od typu oprogramowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 41,
    "question": "Model rozwoju wpływa na koszty tworzenia oprogramowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 42,
    "question": "Scrum jest pełnym, kompletnym przepisem na zarządzanie projektem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 43,
    "question": "Scrum jest planem ramowym (framework) do zarządzania złożonymi problemami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 44,
    "question": "W Scrum przejrzystość oznacza, że proces tworzenia produktu ma być widoczny.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 45,
    "question": "W Scrum kontrola (inspection) służy wykrywaniu problemów przez częste badanie artefaktów i postępu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 46,
    "question": "Adaptacja w scrum polega na jak najszybszym usprawnieniu procesu przy spadku jakości.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 47,
    "question": "Zespół Scrum powinien mieć nie więcej niż 10 osób.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 48,
    "question": "Scrum Master odpowiada za przestrzeganie zasad Scrum i usuwanie przeszkód.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 49,
    "question": "Product Owner w Scrum reprezentuje potrzeby interesariuszy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 50,
    "question": "Scrum pracuje iteracyjnie i przyrostowo.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 51,
    "question": "Jedna iteracja w Scrum nazywa się sprintem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 52,
    "question": "Sprint w Scrum zwykle trwa dokładnie miesiąc.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 53,
    "question": "W trakcie sprintu w Scrum nie mogą być wprowadzone zmiany zagrażające celowi sprintu lub jakości.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 54,
    "question": "Sprint w Scrum może zostać przerwany przez właściciela produktu, gdy cel sprintu przestanie być ważny.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 55,
    "question": "W Scrum w trakcie sprintu zawsze wolno zmieniać cel sprintu bez ograniczeń.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 56,
    "question": "Każdy sprint w Scrum ma cztery rodzaje wydarzeń.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 57,
    "question": "Scrum ma trzy artefakty.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 58,
    "question": "Rejestr produktu w Scrum to uporządkowana lista zadań do udoskonalania produktu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 59,
    "question": "Przyrost w Scrum musi spełniać Definition of Done (DoD), a gdy nie spełnia – wraca do rejestru produktu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 60,
    "question": "Rejestr sprintu w Scrum zawiera cel sprintu, plan dostarczenia przyrostu i zadania wybrane z rejestru produktu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 61,
    "question": "Przyrost w Scrum jest konkretnym wynikiem, który przybliża projekt do celu produktu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 62,
    "question": "Scrum jest metodą zwinną.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 63,
    "question": "Scrum pomaga szybko reagować na zmiany wymagań.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 64,
    "question": "Scrum wprowadza do procesu punkt widzenia interesariuszy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 65,
    "question": "Scrum jest zawsze łatwy do wdrożenia.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 66,
    "question": "Scrum bywa abstrakcyjny i może być trudny do wprowadzenia.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 67,
    "question": "Planning poker służy do szacowania pracy dla zadań przenoszonych do sprintu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 68,
    "question": "W tradycyjnych modelach zarządzania kierownik dzieli pracę na zadania (tasks) i etapy (milestones).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 69,
    "question": "Wykres Gantta przedstawia harmonogram projektu w sposób graficzny.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 70,
    "question": "Na wykresie Gantta romby reprezentują etapy, a paski zadania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 71,
    "question": "Sieć PERT przedstawia harmonogram jako graf skierowany.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 72,
    "question": "W sieci PERT wierzchołki reprezentują zadania i etapy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 73,
    "question": "W Scrum ryzyko jest zwykle widoczne późno, bo feedback jest rzadki.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 74,
    "question": "W metodach zwinnych częsty feedback umożliwia szybszą reakcję na ryzyko.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 75,
    "question": "W tradycyjnym podejściu kierownik projektu rozpoznaje zagrożenia i tworzy plany przeciwdziałania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 76,
    "question": "Ocena ryzyka nie jest potrzebna do przygotowania planów przeciwdziałania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 77,
    "question": "Strategie unikania jako plan przeciwdziałania mają zmniejszać prawdopodobieństwo wystąpienia ryzyka.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 78,
    "question": "Strategie minimalizacji jako plan przeciwdziałania mają zmniejszać wpływ zagrożenia.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 79,
    "question": "Plany awaryjne przygotowuje się na wypadek najpoważniejszych zagrożeń w projekcie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 80,
    "question": "Po ustaleniu planów przeciwdziałania nie trzeba ich aktualizować.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 81,
    "question": "Scrum ogranicza się tylko i wyłącznie do inżynierii oprogramowania",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 82,
    "question": "Inżynieria wymagań obejmuje zbieranie, analizowanie, zatwierdzanie i zarządzanie wymaganiami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 83,
    "question": "Wymaganie musi być niejednoznaczne, aby dało się je łatwo doprecyzować.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 84,
    "question": "Wymaganie powinno być weryfikowalne (testowalne) lub mierzalne.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 85,
    "question": "Interesariusz to wyłącznie osoba, która będzie końcowym użytkownikiem systemu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 86,
    "question": "Interesariusz może mieć zarówno bezpośredni, jak i pośredni wpływ na oprogramowanie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 87,
    "question": "Interesariuszem może być organizacja lub inny podmiot, nie tylko pojedyncza osoba.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 88,
    "question": "Inżynieria wymagań jest jedną z ostatnich czynności w inżynierii oprogramowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 89,
    "question": "Interesariusze są głównym źródłem wymagań.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 90,
    "question": "Dziedzina zastosowania jest jednym ze źródeł wymagań.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 91,
    "question": "Źródła wymagań zawsze są stałe i nie zmieniają się w trakcie projektu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 92,
    "question": "Wymagania funkcjonalne mówią, jakie usługi/funkcje będzie dostarczać oprogramowanie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 93,
    "question": "Wymagania niefunkcjonalne określają, co system ma robić.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 94,
    "question": "Wymagania niefunkcjonalne definiują ograniczenia dla rozwiązań.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 95,
    "question": "Wymagania niefunkcjonalne mają bezpośredni wpływ na jakość oprogramowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 96,
    "question": "Wymagania niefunkcjonalne mówią, jak system powinien dostarczać usługi.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 97,
    "question": "Wymagania biznesowe są najbardziej ogólne (wysokopoziomowe).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 98,
    "question": "Wymagania biznesowe rzadko ulegają zmianom.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 99,
    "question": "Wymagania użytkowników są bardziej szczegółowe niż wymagania biznesowe.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 100,
    "question": "Wymagania biznesowe są bardziej szczegółowe niż wymagania systemowe.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 101,
    "question": "Wymagania systemowe opisują szczegóły tego, co oprogramowanie powinno dostarczać.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 102,
    "question": "Interesariusze często nie wiedzą, co oprogramowanie powinno robić.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 103,
    "question": "Interesariusze mogą mieć nierealne oczekiwania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 104,
    "question": "Słownictwo dziedzinowe interesariuszy może zawierać ukryte znaczenia.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 105,
    "question": "Różni interesariusze mogą mieć sprzeczne oczekiwania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 106,
    "question": "User stories są głównym narzędziem analizy wymagań w metodach zwinnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 107,
    "question": "User stories są źródłem zadań (tasks) koniecznych do implementacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 108,
    "question": "User story jest kompletnym, pełnym opisem wymagania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 109,
    "question": "Kryteria akceptacji służą sprawdzeniu, czy wymaganie zrealizowano poprawnie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 110,
    "question": "Struktura 5W user story zawiera element „ponieważ <dlaczego>”.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 111,
    "question": "Struktura BDD user story obejmuje scenariusze w formacie Given/When/Then.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 112,
    "question": "W 5W występują pola <kto>, <kiedy>, <gdzie>, <co>, <dlaczego>.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 113,
    "question": "Struktura user story nie może być zapisana w formie scenariuszy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 114,
    "question": "Scenariusze mogą być stosowane zarówno w metodach tradycyjnych, jak i zwinnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 115,
    "question": "Scenariusz opisuje interakcję użytkownika z oprogramowaniem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 116,
    "question": "Użytkownik w scenariuszu musi być człowiekiem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 117,
    "question": "Scenariusz musi określać stan systemu przed rozpoczęciem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 118,
    "question": "Scenariusz musi opisywać typowy przebieg czynności.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 119,
    "question": "Scenariusz musi określać wyjątki i sposób ich obsługi.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 120,
    "question": "Scenariusz powinien zawierać informacje o czynnościach wykonywanych równolegle.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 121,
    "question": "Scenariusz nie musi określać stanu systemu po zakończeniu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 122,
    "question": "Pojedynczy przypadek użycia reprezentuje raczej zbiór scenariuszy niż jeden scenariusz.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 123,
    "question": "Diagram przypadków użycia UML wykorzystuje aktorów i elipsy przypadków użycia.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 124,
    "question": "Prototypowanie jest stosowane zarówno w tradycyjnych jaki i zwinnych metodach wytwarzania oprogramowania",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 125,
    "question": "Etnografia polega na obserwacji zwyczajów pracy przyszłych użytkowników.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 126,
    "question": "Etnografia może ujawnić zwyczaje nieujęte w oficjalnych dokumentach.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 127,
    "question": "Etnografia może być użyta do analizy formalnie zdefiniowanych wymagań.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 128,
    "question": "Wprowadzenie prototypu do środowiska pracy może zmienić zachowania i ujawnić nowe fakty.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 129,
    "question": "Defekty w wymaganiach są tańsze w naprawie niż defekty w kodzie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 130,
    "question": "Testowanie akceptacyjne może być użyte do zatwierdzania wymagań.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 131,
    "question": "Wymagania w trakcie projektu nie mogą się zmieniać i najczęściej się nie zmieniają.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 132,
    "question": "Wymagania nie zmieniają się, jeśli na początku zostały dobrze spisane.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 133,
    "question": "Projektowanie architektoniczne jest końcową fazą projektu, wykonywaną po implementacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 134,
    "question": "Proces projektowania architektonicznego składa się m.in. ze strukturalizacji systemu modelowania sterowania i podziału na moduły.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 135,
    "question": "Podsystem to część systemu, której usługi zależą od usług innych podsystemów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 136,
    "question": "Podsystemy składają się z modułów i mają interfejs do komunikacji z innymi podsystemami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 137,
    "question": "Pojedynczy podsystem można rozpatrywać jako samodzielny system.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 138,
    "question": "Moduł zazwyczaj może być rozpatrywany jako niezależny system.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 139,
    "question": "Moduł oferuje co najmniej jedną usługę i może korzystać z usług innego modułu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 140,
    "question": "Pojedynczy moduł zwykle składa się z innych modułów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 141,
    "question": "Moduł nie jest komponentem systemu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 142,
    "question": "Statyczny model strukturalny obejmuje komponenty lub podsystemy, które można zbudować jako niezależne jednostki.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 143,
    "question": "Model dynamiczny procesu nie przedstawia podziały systemu na procesy czasu wykonania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 144,
    "question": "Model interfejsów definiuje usługi oferowane przez każdy podsystem za pośrednictwem jego interfejsu publicznego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 145,
    "question": "Model związków obejmuje związki takie jak przepływ danych między podsystemami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 146,
    "question": "Dokumentacja architektury systemu może składać się z: statycznego modelu strukturalnego, modelu dynamicznego procesu, modelu interfejsów, modelu związków.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 147,
    "question": "Architektura systemu może wpływać m.in. na efektywność, bezpieczeństwo, dostępność i konserwację.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 148,
    "question": "Im bliżej 1 jest wartość I, tym komponent jest bardziej niezależny i „odpowiedzialny”.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 149,
    "question": "Architektura może być zbudowana wyłącznie z komponentów „maksymalnie niezależnych”, bez szkody dla możliwości modyfikacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 150,
    "question": "Efektywność często podnosi się przez użycie niewielkiej liczby komponentów gruboziarnistych, rzadko się komunikujących.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 151,
    "question": "Poufność (bezpieczeństwo) zwykle osiąga się przez strukturę niewarstwową i umieszczanie krytycznych elementów w warstwach zewnętrznych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 152,
    "question": "Dostępność zwiększa się przez stosowanie komponentów redundantnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 153,
    "question": "Konserwację (maintainability) wspiera się poprzez dużą liczbę drobnoziarnistych, samodzielnych komponentów łatwych do zmiany.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 154,
    "question": "Miara niestabilności pozwala oszacować jak bardzo prawdopodobne jest to, że dany komponent nie ulegnie zmianom w przyszłości.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 155,
    "question": "Model repozytorium jest typowy dla systemów przetwarzających małe ilości danych wokół centralnej bazy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 156,
    "question": "Ewolucja systemu w modelu repozytorium może być łatwa ze względu na narzucony model danych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 157,
    "question": "Wadą repozytorium jest konieczność narzucenia wspólnego modelu danych wszystkim podsystemom.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 158,
    "question": "Model klient–serwer składa się z serwerów oferujących usługi, klientów korzystających z usług i sieci (nie zawsze koniecznej).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 159,
    "question": "Model repozytorium zapewnia efektywny sposób współdzielenia dużych ilości danych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 160,
    "question": "Model klient-serwer posiada wspólny model danych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 161,
    "question": "Model klient-serwer jest architekturą rozproszoną.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 162,
    "question": "Model maszyny abstrakcyjnej to inaczej model warstwowy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 163,
    "question": "Architektura warstwowa jest trudna do przenoszenia i modyfikowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 164,
    "question": "Model maszyny abstrakcyjnej to model warstwowy, gdzie każda warstwa oferuje usługi używane do budowy kolejnej.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 165,
    "question": "Podejście warstwowe jest łatwe w zastosowaniu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 166,
    "question": "„Czysty” model warstwowy zawsze zwiększa wydajność systemu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 167,
    "question": "W sterowaniu scentralizowanym jeden podsystem odpowiada całkowicie za sterowanie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 168,
    "question": "W sterowaniu zdarzeniami jeden podsystem odpowiada całkowicie za sterowanie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 169,
    "question": "W sterowaniu zdarzeniami każdy z podsystemów może reagować na zdarzenia pochodzące z zewnątrz.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 170,
    "question": "Model wywołanie–powrót dotyczy systemów sekwencyjnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 171,
    "question": "Modelu menedżera nie można stosować w przypadku systemów współbieżnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 172,
    "question": "Zaletą wywołanie–powrót jest łatwa analiza przepływu sterowania i deterministyczne działanie, a wadą utrudniona obsługa wyjątków.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 173,
    "question": "Podstawowe modele sterowania zdarzeniami to: Model rozgłaszania i model wywołanie–powrót.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 174,
    "question": "Podstawowe modele sterowania zdarzeniami to: Model z przerwaniami i model rozgłaszania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 175,
    "question": "W modelu rozgłaszania zdarzenie jest ogłoszeniem dla wszystkich podsystemów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 176,
    "question": "W modelu z przerwaniami  zewnętrzne przerwania są wykrywane przez obsługę przerwań i przekazywane do odpowiedniego komponentu, gdzie są przetwarzane.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 177,
    "question": "W modelu rozgłaszania zaletą jest brak informacji zwrotnej, co do tego, czy zdarzenie zostało obsłużone.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 178,
    "question": "W modelu rozgłaszania zaletą jest prostota ewolucji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 179,
    "question": "w modelu z przerwaniami zaletą są szybkie odpowiedzi na zdarzenia, a wadą złożoność programowania i trudności z zatwierdzeniem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 180,
    "question": "Model przepływu danych to inaczej model potokowy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 181,
    "question": "W modelu obiektowym obiekty są luźno od siebie uzależnione.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 182,
    "question": "W modelu obiektowym obiekty nie są luźno od siebie uzależnione.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 183,
    "question": "Model obiektowy nie może być zastosowany zarówno w systemach współbieżnych, jak i sekwencyjnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 184,
    "question": "Architektura potokowa umożliwia wielokrotne użycie przekształceń.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 185,
    "question": "Model potokowy jest łatwy do zaimplementowania zarówno w systemach sekwencyjnych, jak i współbieżnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 186,
    "question": "W modelu potokowym Konieczne jest wprowadzenie wspólnego formatu danych zrozumiałego dla wszystkich przekształceń.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 187,
    "question": "Model potokowy nadaje się do systemów interaktywnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 188,
    "question": "Zatwierdzanie (Validation) sprawdza, czy oprogramowanie spełnia potrzeby interesariuszy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 189,
    "question": "Weryfikacja (Verification) sprawdza, czy oprogramowanie jest zgodne ze specyfikacją.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 190,
    "question": "Zatwierdzanie odpowiada na pytanie „Czy oprogramowanie jest tworzone w odpowiedni sposób?”.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 191,
    "question": "Weryfikacja odpowiada na pytanie „Czy tworzone jest odpowiednie oprogramowanie?”.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 192,
    "question": "Kontrola jakości (QC) i zapewnianie jakości (QA) są pojęciami zamiennymi.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 193,
    "question": "QC to proces sprawdzania poziomu jakości produktu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 194,
    "question": "QA to zbiór działań zmierzających do poprawienia jakości w cyklu rozwojowym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 195,
    "question": "Testowanie statyczne polega na badaniu kodu i dokumentacji bez uruchamiania kodu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 196,
    "question": "Analiza statyczna jest formą testowania statycznego wykonywaną narzędziowo.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 197,
    "question": "Testowanie dynamiczne nie wymaga wykonywalnej formy kodu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 198,
    "question": "Testowanie statyczne i dynamiczne wzajemnie się wykluczają.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 199,
    "question": "Na początku projektu testowanie dynamiczne generuje zwykle wysokie koszty.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 200,
    "question": "Model V wiąże określone poziomy testów z konkretnymi artefaktami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 201,
    "question": "Granica między testami statystycznymi, a testowaniem w poszukiwaniu defektów jest rozmyta.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 202,
    "question": "Granica między testami statystycznymi, a testowaniem w poszukiwaniu defektów jest ostra.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 203,
    "question": "Wynik testu ujawniający defekt nazywa się wynikiem negatywnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 204,
    "question": "Wynik testu nieujawniający defektu nazywa się wynikiem pozytywnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 205,
    "question": "Testowanie dynamiczne może służyć do badania atrybutów czasu wykonania (np. wydajności, dostępności).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 206,
    "question": "Defekt to wada w kodzie, która może powodować błędy (errors).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 207,
    "question": "Głównym celem testowania dynamicznego jest wykrycie defektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 208,
    "question": "Testowanie regresji polega na wykonaniu testów, które wykryły defekt oraz tych potencjalnie dotkniętych zmianą.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 209,
    "question": "Testy regresji mają na celu sprawdzić, czy defekt został usunięty, a nie tylko ukryty.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 210,
    "question": "Testowanie regresji jest wykonywane przed naprawą defektu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 211,
    "question": "Całkowity koszt testowania statycznego jest większy niż całkowity koszt testowania dynamicznego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 212,
    "question": "Podczas jednej sesji przeglądu zwykle wykrywa się mniej defektów niż w jednej sesji testowania dynamicznego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 213,
    "question": "W testowaniu statycznym defekty mogą być nie tylko wykrywane, ale też lokalizowane.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 214,
    "question": "Testowanie statyczne może dotyczyć także innych artefaktów niż kod.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 215,
    "question": "Ręczne testowanie statyczne dobrze skaluje się do bardzo dużej ilości kodu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 216,
    "question": "Autor (właściciel) jako rola inspekcji dostarcza artefakt i usuwa wykryte defekty.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 217,
    "question": "Recenzent jako rola inspekcji ma zadanie znaleźć defekty i inne problemy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 218,
    "question": "Czytelnik jako rola inspekcji interpretuje sprawdzany kod lub dokument.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 219,
    "question": "Sekretarz jako rola inspekcji zapisuje wyniki spotkania inspekcyjnego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 220,
    "question": "Moderator jako rola inspekcji planuje i zarządza spotkaniami inspekcyjnymi.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 221,
    "question": "Główny moderator jako rola inspekcji ustala standardy inspekcji w firmie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 222,
    "question": "Defekty danych mogą dotyczyć braku inicjalizacji zmiennych przed użyciem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 223,
    "question": "Defekty sterowania dotyczą m.in. tego, czy każda pętla się kończy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 224,
    "question": "Defekty wejścia–wyjścia mogą polegać na awarii po podaniu nieoczekiwanych danych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 225,
    "question": "Defekty interfejsu mogą dotyczyć niezgodności typów argumentów i parametrów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 226,
    "question": "Defekty zarządzania pamięcią mogą dotyczyć błędnego użycia wskaźników lub braku zwalniania pamięci.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 227,
    "question": "Narzędzia SCA analizują kod źródłowy bez uruchamiania programu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 228,
    "question": "Analizatory statyczne zawsze znają pełen kontekst kodu i nie dają błędnych wyników.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 229,
    "question": "Narzędzia SAST to analizatory statyczne ukierunkowane na bezpieczeństwo aplikacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 230,
    "question": "Testowanie dynamiczne polega na uruchamianiu oprogramowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 231,
    "question": "Testy integracyjne sprawdzają współpracę komponentów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 232,
    "question": "Testy systemowe dotyczą ukończonej wersji oprogramowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 233,
    "question": "Testy akceptacyjne potwierdzają spełnienie wymagań interesariuszy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 234,
    "question": "Testy integracyjne są wykonywane wyłącznie po testach systemowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 235,
    "question": "Testowanie akceptacyjne może być wykonane przez klienta.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 236,
    "question": "Testowanie defektów polega na porównywaniu zachowania programu ze specyfikacją.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 237,
    "question": "Przypadek testowy zawiera dane wejściowe i oczekiwane wyniki.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 238,
    "question": "Główną trudnością testowania jest zaprojektowanie jak największej liczby testów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 239,
    "question": "Jakość testów może być oceniana za pomocą metryk.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 240,
    "question": "Testowanie defektów jest niezależne od projektowania przypadków testowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 241,
    "question": "Testowanie funkcjonalne jest nazywane testowaniem czarnej skrzynki.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 242,
    "question": "W testowaniu funkcjonalnym kod źródłowy jest zawsze dostępny.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 243,
    "question": "Testowanie funkcjonalne może być stosowane na każdym poziomie testowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 244,
    "question": "Podział na klasy równoważności jest pierwszym krokiem projektowania testów funkcjonalnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 245,
    "question": "Klasy równoważności zawierają dane o podobnej charakterystyce.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 246,
    "question": "Klasy równoważności dzielą tylko dane poprawne.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 247,
    "question": "Testowanie wartości brzegowych jest częścią testowania funkcjonalnego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 248,
    "question": "Testy powinny być wybierane wyłącznie ze środka klas równoważności.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 249,
    "question": "Wartości brzegowe leżą na granicach klas równoważności.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 250,
    "question": "Testuje się także wartości tuż poza granicami klas.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 251,
    "question": "Testowanie wartości brzegowych zwiększa szansę wykrycia defektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 252,
    "question": "Testowanie wartości brzegowych zakłada, że błędy często występują na granicach zakresów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 253,
    "question": "Testowanie strukturalne jest nazywane testowaniem białej skrzynki.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 254,
    "question": "W testowaniu strukturalnym kod źródłowy jest dostępny.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 255,
    "question": "Testowanie strukturalne nie może być stosowane w testach integracyjnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 256,
    "question": "Testowanie strukturalne ignoruje warunki w kodzie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 257,
    "question": "Testowanie strukturalne nie dotyczy ścieżek wykonania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 258,
    "question": "Ścieżka to sekwencja wykonywanych instrukcji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 259,
    "question": "Ścieżki pierwotne różnią się co najmniej jedną instrukcją.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 260,
    "question": "Przetestowanie wszystkich ścieżek pierwotnych gwarantuje brak defektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 261,
    "question": "Graf przepływu sterowania (CFG) pomaga znaleźć ścieżki pierwotne.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 262,
    "question": "Złożoność cyklomatyczna to minimalna liczba testów strukturalnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 263,
    "question": "Każdy prosty warunek powinien być sprawdzony jako prawdziwy i fałszywy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 264,
    "question": "Testowanie integracyjne weryfikuje interakcję komponentów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 265,
    "question": "Testowanie integracyjne jest procesem przyrostowym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 266,
    "question": "Testowanie integracyjne metodą wielkiego wybuchu zachodzi, gdy integracja tylko dwóch kompnentów jest niemożliwa i potrzeba ich więcej.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 267,
    "question": "Podejście zstępujące zaczyna od komponentów niskopoziomowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 268,
    "question": "Podejście wstępujące wymaga sterowników testów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 269,
    "question": "W praktyce oba podejścia (zstępujące i wstępujące) są często stosowane równocześnie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 270,
    "question": "Dubler testowy zastępuje brakujący komponent.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 271,
    "question": "Atrapa (dummy) posiada pełną implementację.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 272,
    "question": "Fałszywka (fake) ma działającą, lecz uproszczoną implementację.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 273,
    "question": "Namiastka (stub) odpowiada tylko na określone zapytania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 274,
    "question": "Szpieg (spy) rejestruje informacje o wywołaniach.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 275,
    "question": "Makieta (mock) sprawdza poprawność wywołań.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 276,
    "question": "Mock może zgłosić wyjątek przy nieprawidłowym użyciu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 277,
    "question": "Testy integracyjne skupiają się głównie na interfejsach.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 278,
    "question": "Parametry interfejsów można testować testami brzegowymi.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 279,
    "question": "Referencje i wskaźniki nie wymagają szczególnej uwagi.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 280,
    "question": "Pamięć dzielona powinna być testowana przy różnych kolejnościach wykonania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 281,
    "question": "Testy powinny sprawdzać reakcję na awarię komponentu wywoływanego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 282,
    "question": "Przekazywanie komunikatów testuje się testami przeciążeniowymi.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 283,
    "question": "Testowanie systemowe odbywa się po zakończeniu prac rozwojowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 284,
    "question": "Testy przeciążeniowe badają zachowanie przy nadmiernym obciążeniu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 285,
    "question": "Testy zgodności sprawdzają spełnienie standardów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 286,
    "question": "Testy przenośności sprawdzają działanie na różnych platformach.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 287,
    "question": "Testy niezawodności nie są częścią testów systemowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 288,
    "question": "Testowanie systemowe nie obejmuje wymagań niefunkcjonalnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 289,
    "question": "W programowaniu obiektowym poziomy testowania wymagają całkowicie innego podejścia, a nie tylko dostosowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 290,
    "question": "Metryki w testowaniu służą do oceny postępu oraz jakości testów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 291,
    "question": "W programowaniu obiektowym obiekty w podsystemie zwykle mają wspólny „punkt wejścia”.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 292,
    "question": "Obiekt jako komponent jest zazwyczaj większy niż pojedynczy podprogram.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 293,
    "question": "Ponowne użycie obiektów może utrudniać testowanie, gdy brak dostępu do kodu źródłowego klas.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 294,
    "question": "Metryki były projektowane wyłącznie dla jednej metody testowania i zawsze są niezależne od poziomu testów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 295,
    "question": "Testowanie jednostkowe w programowaniu obiektowym polega na testowaniu metod obiektu osobno (jeśli to możliwe).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 296,
    "question": "W testowaniu jednostkowym metod obiektu można użyć zarówno testów funkcjonalnych, jak i strukturalnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 297,
    "question": "Testowanie klas jest poziomem nadrzędnym wobec testowania jednostkowego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 298,
    "question": "Testy integracyjne w programowaniu obiektowym powinny testować grona wspólnie używanych obiektów i być oparte na scenariuszach.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 299,
    "question": "Testowanie systemowe i akceptacyjne w programowaniu obiektowym przebiega inaczej niż w kodzie proceduralnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 300,
    "question": "W programowaniu obiektowym granica między testowaniem jednostkowym i integracyjnym jest wyraźniejsza niż w proceduralnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 301,
    "question": "Testowanie klas dotyczy m.in. sekwencji zależnych operacji obiektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 302,
    "question": "Podstawowym wymaganiem testowania jednostkowego w testowaniu klas jest weryfikacja metod obiektu w izolacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 303,
    "question": "Izolację metod w testach jednostkowych można osiągnąć przez użycie dublerów testowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 304,
    "question": "Testowanie setterów i getterów jest zawsze konieczne w każdym projekcie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 305,
    "question": "W testowaniu klas należy sprawdzić wszystkie możliwe stany obiektu, czyli zdarzenia zmieniające stan.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 306,
    "question": "Testowanie przypadków użycia lub scenariuszy opisuje w jaki sposób oprogramowanie będzie używane.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 307,
    "question": "Testowanie wątków w OOP zakłada sprawdzenie reakcji oprogramowania na zdarzenia.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 308,
    "question": "Aby dokładnie testować wątki w systemie sterowanym zdarzeniami, testerzy muszą znać sposób przetwarzania zdarzeń wewnątrz systemu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 309,
    "question": "Testowanie interakcji obiektów weryfikuje ścieżki „metoda–komunikat” od zdarzenia wejściowego do zdarzenia wyjściowego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 310,
    "question": "Testy integracyjne w OOP powinny dotyczyć gron wspólnie używanych obiektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 311,
    "question": "Metryki oceniają postęp i jakość testowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 312,
    "question": "Metryki pokrycia kodu mówią, jaka część kodu jest uruchamiana przez przypadki testowe.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 313,
    "question": "Poziom wymaganego pokrycia powinien zależeć od kontekstu (np. systemy krytyczne mogą wymagać więcej).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 314,
    "question": "Metryki pokrycia kodu mogą pomagać wykryć nadmiarowe przypadki testowe (nieujawniające nowych defektów).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 315,
    "question": "Pokrycie bloków instrukcji potrafi ocenić jakość przetestowania wyrażeń warunkowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 316,
    "question": "Metryka pokrycia instrukcji jest szczególnym przypadkiem pokrycia bloków, gdy blok ma jedną instrukcję.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 317,
    "question": "Pokrycie decyzji to stosunek liczby przetestowanych gałęzi instrukcji sterujących do całkowitej liczby gałęzi.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 318,
    "question": "Pokrycie decyzji zawsze wymaga mniejszej liczby testów niż pokrycie bloków.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 319,
    "question": "Pokrycie decyzji lepiej niż pokrycie bloków sprawdza wyrażenia warunkowe w instrukcjach sterujących.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 320,
    "question": "Wadą pokrycia decyzji jest to, że nie uwzględnia short-circuit evaluation.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 321,
    "question": "Metryka pokrycia ścieżek uwzględnia skracanie obliczeń wartości wyrażeń warunkowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 322,
    "question": "Pokrycie ścieżek zwykle wymaga więcej przypadków testowych niż pokrycie decyzji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 323,
    "question": "W komponentach z wieloma pętlami testy ścieżek powinny ograniczać liczbę iteracji wykonywanych w testach.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 324,
    "question": "Metryki pokrycia wymagań są stosowane głównie w testowaniu funkcjonalnym na poziomie testów systemowych i akceptacyjnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 325,
    "question": "Ogólnie metryki pokrycia wymagań mierzą stosunek liczby przetestowanych wymagań do ich całkowitej liczby.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 326,
    "question": "Metryka pokrycia błędów dotyczy błędów rozumianych jako wyjątki (np. format danych, brak sieci, brak zasobów).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 327,
    "question": "Metryka pokrycia błędów to stosunek obsłużonych w testach błędów do liczby błędów, które system powinien obsługiwać.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 328,
    "question": "Przypadek użycia to zbiór scenariuszy opisujących typowe interakcje z oprogramowaniem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 329,
    "question": "Metryki pokrycia przypadków użycia mogą być opracowane dla przypadków biznesowych i systemowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 330,
    "question": "Liczba wykrytych defektów może pomóc oszacować początkową jakość kodu i jej zmianę w kolejnych sesjach testów i napraw.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 331,
    "question": "Testowanie można zakończyć, gdy liczba wykrytych defektów zaczyna się stabilizować.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 332,
    "question": "Te same przypadki testowe mogą być później użyte w utrzymaniu do wykrywania regresji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 333,
    "question": "Gęstość defektów to liczba defektów przypadająca na liczbę wierszy lub tysiące wierszy kodu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 334,
    "question": "Metryka gęstości defektów nie jest stosowana, bo nie ma definicji wiersza kodu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 335,
    "question": "Procent wykrytych defektów służy do oceny efektywności testowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 336,
    "question": "Procent wykrytych defektów to stosunek liczby wykrytych w testach defektów do szacowanej całkowitej liczby defektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 337,
    "question": "Całkowitą liczbę defektów szacuje się m.in. przez zasiewanie (seeded) defektów – sztuczne wprowadzanie ich do kodu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 338,
    "question": "Im bardziej typy zasianych defektów odpowiadają prawdziwym defektom, tym bardziej wiarygodna jest metryka.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 339,
    "question": "Automatyzacja testów całkowicie eliminuje ryzyko wprowadzania defektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 340,
    "question": "Testy automatyczne mogą pełnić rolę dokumentacji oprogramowania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 341,
    "question": "Automatyzacja testów jest zawsze korzystna, niezależnie od sposobu jej wykonania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 342,
    "question": "Automatyzacja testów nie ma wpływu na proces CI/CD.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 343,
    "question": "Zasady F.I.R.S.T dotyczą automatycznych testów jednostkowych i integracyjnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 344,
    "question": "Zasada „Fast” oznacza, że testy powinny być uruchamiane jak najszybciej.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 345,
    "question": "Testy zgodne z zasadą „Independent” mogą zależeć od wyników poprzednich testów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 346,
    "question": "Testy jednostkowe powinny być możliwe do uruchomienia w różnych środowiskach.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 347,
    "question": "Testy „Self-Validating” wymagają ręcznej analizy raportów w celu sprawdzenia wyniku.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 348,
    "question": "Zasada „Timely” zaleca pisanie testów przed kodem produkcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 349,
    "question": "Metoda TDD zakłada pisanie kodu produkcyjnego przed testami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 350,
    "question": "Testy End-To-End są formą testów funkcjonalnych na poziomie systemowym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 351,
    "question": "Testy E2E zawsze są od początku w pełni zautomatyzowane.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 352,
    "question": "Testy E2E mogą być wykonywane manualnie przed ich automatyzacją.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 353,
    "question": "Dla aplikacji z GUI istnieją narzędzia nagrywające i odtwarzające interakcje użytkownika.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 354,
    "question": "Testy aplikacji webowych korzystają z protokołu WebDriver.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 355,
    "question": "TestFX umożliwia symulowanie interakcji użytkownika z GUI JavaFX.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 356,
    "question": "Selenium jest jedną z bibliotek umożliwiających testowanie aplikacji internetowych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 357,
    "question": "Wzorzec PageObject polega na bezpośrednim testowaniu kodu HTML strony.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 358,
    "question": "Singleton jest wzorcem konstrukcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 359,
    "question": "Singleton jest wzorcem czynnościowym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 360,
    "question": "Metoda fabrykująca jest wzorcem konstrukcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 361,
    "question": "Metoda fabrykująca jest wzorcem strukturalnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 362,
    "question": "Fabryka abstrakcyjna jest wzorcem czynnościowym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 363,
    "question": "Fabryka abstrakcyjna jest wzorcem konstrukcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 364,
    "question": "Budowniczy jest wzorcem strukturalnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 365,
    "question": "Budowniczy jest wzorcem konstrukcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 366,
    "question": "Prototyp jest wzorcem konstrukcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 367,
    "question": "Prototyp jest wzorcem czynnościowym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 368,
    "question": "Singleton zapewnia, że dana klasa może mieć tylko jedną instancję oraz globalny punkt dostępu do niej.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 369,
    "question": "Singleton jest szczególnie użyteczny, gdy zasób powinien być unikalny w systemie (np. wspólne dane konfiguracyjne).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 370,
    "question": "Metoda fabrykująca polega na tworzeniu obiektów przez specjalną metodę zamiast bezpośrednio przez new.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 371,
    "question": "Dzięki metodzie fabrykującej typ tworzonego obiektu może być wybierany w trakcie działania programu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 372,
    "question": "Wzorzec metoda fabrykująca stosuje się m.in. gdy nie da się z góry ustalić, jakich klas obiektów trzeba będzie utworzyć.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 373,
    "question": "Metoda fabrykująca zawsze zwraca dokładnie ten sam konkretny typ w każdej klasie potomnej.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 374,
    "question": "Wzorzec ułatwia dodawanie nowych typów obiektów przy minimalnych zmianach w istniejącym kodzie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 375,
    "question": "Fabryka abstrakcyjna umożliwia tworzenie rodzin powiązanych obiektów bez wskazywania ich konkretnych klas.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 376,
    "question": "Wzorzec fabryka abstrakcyjna udostępnia interfejs do tworzenia grupy powiązanych „produktów” współpracujących ze sobą.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 377,
    "question": "Główną ideą we wzorcu fabryka abstrakcyjna jest uzależnienie kodu klienta od szczegółów tworzenia obiektów, żeby mógł je kontrolować.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 378,
    "question": "Budowniczy oddziela proces tworzenia złożonego obiektu od jego reprezentacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 379,
    "question": "Budowniczy jest szczególnie przydatny, gdy obiekt ma wiele parametrów opcjonalnych lub złożoną strukturę.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 380,
    "question": "Wzorzec budowniczy stosuje się m.in. gdy konstruktor ma zbyt wiele parametrów i spada czytelność kodu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 381,
    "question": "Wzorzec budowniczy wymaga, aby wszystkie pola obiektu były obowiązkowe.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 382,
    "question": "We wzorcu budowniczy ten sam proces budowania może tworzyć różne warianty obiektu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 383,
    "question": "Adapter jest wzorcem strukturalnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 384,
    "question": "Adapter jest wzorcem konstrukcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 385,
    "question": "Most jest wzorcem strukturalnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 386,
    "question": "Most jest wzorcem czynnościowym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 387,
    "question": "Kompozyt jest wzorcem strukturalnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 388,
    "question": "Kompozyt jest wzorcem konstrukcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 389,
    "question": "Dekorator jest wzorcem strukturalnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 390,
    "question": "Dekorator jest wzorcem konstrukcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 391,
    "question": "Fasada jest wzorcem strukturalnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 392,
    "question": "Fasada jest wzorcem czynnościowym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 393,
    "question": "Pyłek jest wzorcem strukturalnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 394,
    "question": "Pyłek jest wzorcem czynnościowym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 395,
    "question": "Proxy jest wzorcem strukturalnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 396,
    "question": "Proxy jest wzorcem konstrukcyjnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 397,
    "question": "Adapter umożliwia współpracę klas o niekompatybilnych interfejsach.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 398,
    "question": "Adapter „opakowuje” obiekt, dostarczając nowy, bardziej oczekiwany interfejs.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 399,
    "question": "Adapter wymaga modyfikacji istniejącej klasy, aby dopasować jej interfejs.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 400,
    "question": "Adapter jest zalecany, gdy chcemy użyć istniejącej klasy, ale jej interfejs nie pasuje do wymaganego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 401,
    "question": "Most oddziela abstrakcję od implementacji, umożliwiając ich niezależny rozwój.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 402,
    "question": "Most tworzy dwie niezależne hierarchie: jedną dla abstrakcji i drugą dla implementacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 403,
    "question": "Most „twardo” wiąże klasę abstrakcji z jedną implementacją na stałe.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 404,
    "question": "Most łączy abstrakcję z implementacją poprzez interfejs.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 405,
    "question": "Kompozyt pozwala budować złożone struktury z prostszych elementów i traktować je jednolicie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 406,
    "question": "Kompozyt umożliwia budowę hierarchii typu część–całość.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 407,
    "question": "W kompozycie klient powinien zawsze rozróżniać, czy pracuje z liściem czy kompozytem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 408,
    "question": "Elementy w kompozycie tworzą zwykle strukturę drzewiastą.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 409,
    "question": "Celem kompozytu jest to, aby klient mógł traktować wszystkie obiekty w strukturze w ten sam sposób.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 410,
    "question": "Dekorator opakowuje obiekt docelowy, aby dynamicznie dodawać do niego nowe funkcje.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 411,
    "question": "Dekoratory można łączyć kaskadowo (dekorator może opakowywać inny dekorator).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 412,
    "question": "Dekorator wymaga tworzenia podklas dla każdej kombinacji rozszerzeń.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 413,
    "question": "Dekorator jest przydatny, gdy trzeba dodawać zadania do poszczególnych obiektów w sposób dynamiczny i „przezroczysty”.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 414,
    "question": "Dekorator jest wskazany, gdy potrzebny jest mechanizm obsługi zadań, które można cofnąć.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 415,
    "question": "Fasada udostępnia prosty interfejs do złożonego systemu lub grupy klas.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 416,
    "question": "Fasada ujawnia wszystkie szczegóły implementacyjne, aby użytkownik mógł nimi sterować.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 417,
    "question": "Jednym z celów fasady jest ukrycie skomplikowanych części systemu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 418,
    "question": "Fasada jest używana, gdy chcemy udostępnić prosty interfejs do podsystemu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 419,
    "question": "Pyłek służy do oszczędzania pamięci poprzez dzielenie wspólnych danych między wiele obiektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 420,
    "question": "Pyłek dzieli dane na zmienne i niezmienne.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 421,
    "question": "Proxy tworzy obiekt zastępczy pośredniczący w dostępie do obiektu właściwego.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 422,
    "question": "Proxy wygląda i zachowuje się jak obiekt docelowy, ale może dodać dodatkową funkcjonalność.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 423,
    "question": "Proxy stosuje się, gdy obiekt docelowy jest „ciężki” do stworzenia (czas/pamięć/zasoby).",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 424,
    "question": "Proxy nie może realizować kontroli dostępu do obiektu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 425,
    "question": "Proxy może opóźniać tworzenie obiektu do momentu, gdy jest to faktycznie potrzebne.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 426,
    "question": "Proxy może służyć do monitorowania lub ograniczania dostępu do obiektu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 427,
    "question": "Łańcuch zobowiązań przekazuje żądanie przez łańcuch obiektów aż do momentu, gdy jeden z nich je obsłuży.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 428,
    "question": "Każdy obiekt w łańcuchu musi obsłużyć żądanie i nie może go przekazać dalej.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 429,
    "question": "Polecenie zamienia żądanie w samodzielny obiekt zawierający wszystkie informacje o tym żądaniu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 430,
    "question": "Dzięki wzorcowi Polecenie można parametryzować obiekty poleceniami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 431,
    "question": "Polecenie nie pozwala na kolejkowanie zadań do wykonania.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 432,
    "question": "Interpreter służy do reprezentacji i interpretacji prostych języków formalnych.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 433,
    "question": "Iterator zapewnia sekwencyjny dostęp do elementów obiektu złożonego bez ujawniania jego reprezentacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 434,
    "question": "Iterator ujawnia szczegóły implementacji kolekcji, aby ułatwić iterację.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 435,
    "question": "Mediator to obiekt zawierający informacje o interakcji między obiektami z danego zbioru.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 436,
    "question": "Mediator pomaga zapewnić luźne powiązanie, bo zapobiega bezpośredniemu odwoływaniu się obiektów do siebie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 437,
    "question": "Pamiątka zapisuje wewnętrzny stan obiektu w zewnętrznej jednostce, aby można było go później odtworzyć.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 438,
    "question": "Pamiątka łamie hermetyzację, bo stan jest udostępniany publicznie wszystkim obiektom.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 439,
    "question": "Obserwator definiuje zależność jeden-do-wielu między obiektami.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 440,
    "question": "Gdy stan obiektu obserwowanego we wzorcu obserwator się zmienia, wszystkie zależne obiekty są automatycznie informowane i aktualizowane.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 441,
    "question": "Wzorzec Stan pozwala obiektowi zmieniać zachowanie w wyniku zmiany jego wewnętrznego stanu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 442,
    "question": "Wzorzec strategia definiuje rodzinę algorytmów, kapsułkuje je i umożliwia ich zamienne stosowanie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 443,
    "question": "Metoda szablonowa definiuje szkielet algorytmu w klasie bazowej.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 444,
    "question": "We wzorcu metoda szablonowa szczegóły implementacji kroków algorytmu są pozostawiane klasom pochodnym.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 445,
    "question": "We wzorcu odwiedzający reprezentuje operację wykonywaną na elementach struktury obiektów.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 446,
    "question": "Wzorzec odwiedzający pozwala zdefiniować nową operację bez zmieniania klas elementów, na których działa.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 447,
    "question": "Zależność jest najsłabszym rodzajem relacji w diagramie klas UML.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 448,
    "question": "Zależność oznacza, że jedna klasa trwale przechowuje referencję do drugiej klasy.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 449,
    "question": "Relację zależności oznaczamy przerywaną linią z pustym grotem strzałki.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 450,
    "question": "Zależność idczytujemy jako \"używa tymczasowo\"?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 451,
    "question": "Jeśli obiekt jest przekazywany do metody jako parametr, to najczęściej mamy do czynienia z zależnością.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 452,
    "question": "Asocjacja oznacza relację typu „używa tymczasowo”.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 453,
    "question": "Asocjacja oznacza realację typu \"ma\"?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 454,
    "question": "Asocjację oznaczamy w UML za pomocą ciągłej linii z pełnym grotem strzałki.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 455,
    "question": "Asocjacja oznacza, że jeden obiekt ma referencję do drugiego obiektu.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 456,
    "question": "Asocjacja jest słabsza niż zależność.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 457,
    "question": "Agregacja odczytujemy jako \"skłąda się z\"?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 458,
    "question": "Agregacja jest rodzajem asocjacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 459,
    "question": "W agregacji jedna klasa jest częścią drugiej, ale może istnieć niezależnie.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 460,
    "question": "Agregacje oznaczamy jako ciągła linia z pełnym grotem ale niezamalowanym diamentem na początku.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 461,
    "question": "Kompozycje odczytujemy jako \"ma\"?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 462,
    "question": "Kompozycja to silniejsza forma agregacji.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 463,
    "question": "Kompozycje odczytujemy jako \"jest częścią\"?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 464,
    "question": "W kompozycji obiekty mogą istnieć bez obiektu, do którego należą.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 465,
    "question": "Kompozycja ma zamalowany diament.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 466,
    "question": "Generalizacja to inaczej dziedziczenie?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 467,
    "question": "Generalizację oznaczamy jako ciągła linia z pustym grotem strzałki?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 468,
    "question": "Generalizacja oznacza, że jedna klasa dzidziczy po innej klasie?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 469,
    "question": "Generalizację odczytujemy jako \"jest\" / \"to\"",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 470,
    "question": "Implementacja oznacza realację pomiędzy klasą a typem wyliczeniowym?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 471,
    "question": "Implementacja oznacza relację pomiędzy klasą a interfejsem?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 472,
    "question": "Implementacje oznacza się za pomocą przerywanej lini z pustym grotem?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 473,
    "question": "Klasa implementująca interfejs musi zdefiniować wszystkie jego metody?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 474,
    "question": "Interfejs może zawierać tylko deklaracje metod?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 475,
    "question": "Implementacja jest formą dziedzicenia?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 476,
    "question": "Diagram aktywności służy do opisu przepływu sterowania w procesie lub fragmencie kodu?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 477,
    "question": "Diagram aktywności może zawierać więcej niż jedną aktywność końcową?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 478,
    "question": "Aktywność początkowa jest oznaczana zamalowanym czarnym kółkiem?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 479,
    "question": "Aktywność końcowa jest oznaczana zamalowanym kółkiem otoczonym drugim kółkiem?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 480,
    "question": "Typowe aktywności są przedstawiane jako prostokąty z zaokrąglonymi rogami?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 481,
    "question": "Romb decyzyjny reprezentuje warunek logiczny i rozgałęzienie?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 482,
    "question": "Z jednego rombu decyzyjnego może jednocześnie wypływać więcej niż jedna aktywna gałąź.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 483,
    "question": "Po rozgałęzieniu wykonanym rombem należy złączyć przepływ również rombem.",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 484,
    "question": "Symbol \"+\" przy atrybucie lub metodzie oznacza dostęp publiczny?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 485,
    "question": "Symbol \"-\" przy atrybucie lub metodzie oznacza dostęp publiczny?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      1
    ]
  },
  {
    "id": 486,
    "question": "Symbol \"#\" przy atrybucie lub metodzie oznacza dostęp protected?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  },
  {
    "id": 487,
    "question": "Symbol \"~\" przy atrybucie lub metodzie oznacza dostęp pakietowy?",
    "answers": [
      "Tak",
      "Nie"
    ],
    "correct": [
      0
    ]
  }
]
	}
}
